# CSS

## 浏览器渲染页面过程

- 用户在浏览器中输入网址后，浏览器会先对输入的地址进行解析。比如用的协议 http 还是 https
- 之后会根据域名进行 IP 的寻址
  - 寻址先从缓存开始，如 host
  - 之后再访问 DNS 服务器，一层一层直至访问到根服务器
  - 服务器再把 IP 告诉客户端
- 客户端拿到 IP 后发起请求
  - 与服务器进行 HTTP 连接建立（3 次握手）
- 建立成功后服务器返回数据，浏览器进行渲染
  - DOM 树构建、CSSOM 树的构建、JavaScript 资源下载
    - CSS 的重排重绘，CSSOM 与 DOM 一起进行绘制
    - JavaScript 资源的阻塞
- 渲染出页面

## 回流和重绘

回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置
重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制

具体的浏览器解析渲染机制如下所示：

解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树

将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)

Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）

Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素

Display:将像素发送给 GPU，展示在页面上

## 三次握手

> 三次握手是通信双方建立 TCP 连接的过程，作用是明确双方的收、发能力是正常的

1. 第一次握手：客户端向服务端发送消息，请求连接。此时服务端明白客户端的发送、自己的接收能力没问题
2. 第二次握手：服务端向客户端返回消息，告知同意连接请求。此时客户端明白自己的发送接收、服务端的发送接收没问题
3. 第三次握手：客户端返回消息，告知服务端确认建立连接。此时服务端明白自己的发送和客户端的接收没问题

## 四次挥手

> 这是通信双方断开 TCP 连接的过程

1. 第一次挥手，客户端发送请求，告知服务端自己没有数据可发送了，请求断开连接（这个阶段不再发送数据，但仍能接收数据）
2. 第二次挥手，服务端接收请求，返回消息告知收到请求，但还没准备好断开连接（这个阶段服务端仍能发送数据，断开连接需要应用层决定）
3. 第三次挥手，服务端处理完善后事宜，发送消息给客户端，告知同意断开连接（这个阶段服务端不再向客户端发送数据，并等待客户端的最后一次消息）
4. 第四次挥手，客户端返回确认消息，服务端接收到确认消息，关闭连接。客户端等待一段时间，若没有接收到服务端需要重发确认信息的请求，则认为服务端已经关闭。客户端关闭连接

## BFC

> BFC 是 CSS 中的一个渲染机制，BFC 就相当于一个盒子，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它。

### 形成条件（任意一条）

- float 的值不是 none
- position 的值不是 static 或者 relative
- display 的值是 inline-block,table-cell,flex,table-caption 或者 inline-flex
- overflow 的值不是 visible

### 特性(解决的问题)

1. 同属于一个 BFC 的两个块级盒子，在垂直方向上会发生 margin 重叠。
   (给其中一个盒子放入另外一个 BFC 中，解决 margin 重叠)

2. 浮动元素是一个单独的 BFC。两个 BFC 之间不会影响。
   (解决浮动元素浮在其它元素表面上的问题。一般用于图文环绕。)

3. 计算 BFC 的高度时，浮动元素也计算在内。
   (给浮元素触发 BFC。解决高度塌陷问题。)

# HTML

# JavaScript

## 原型

1. 函数的 prototype 属性

- 每个函数都有一个 prototype 属性, 它默认指向一个 Object 空对象(即称为: 原型对象)
- 原型对象中有一个属性 constructor, 它指向函数对象

2. 给原型对象添加属性(一般都是方法)

- 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

## 显式原型与隐式原型

1. 每个 function 都有一个 prototype, 即显示原型
2. 每个实例对象都有一个 `__proto__`
3. 对象的隐式原型的值为其对应构造函数的显式原型的值

- 函数的 prototype 属性: 在定义函数时自动添加的, 默认值是一个空 object 对象
- 对象的`__proto__`属性: 在创建对象时自动添加的, 默认值为构造函数的 prototype 的值

## 原型链

- 访问一个对象的属性时，
- 先在自身属性中查找，找到返回
- 如果没有, 再沿着`__proto__`这条链向上查找, 找到返回
- 如果最终没找到, 返回 undefined

## Promise 理解（重点）以及自己的实现过程

- Promise 是 js 中进行异步编程的新解决方案
- 从方法上讲, Promise 是一个构造函数
- 从功能上讲, Promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值

## 闭包的原理

1. 如何产生闭包?

- 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

2. 闭包到底是什么?

- 使用 chrome 调试查看
- 理解一: 闭包是嵌套的内部函数(绝大部分人)
- 理解二: 包含被引用变量(函数)的对象(极少数人)
- 注意: 闭包存在于嵌套的内部函数中

3. 产生闭包的条件?

- 函数嵌套
- 内部函数引用了外部函数的数据(变量/函数)

## 作用域的概念

. 理解

- 就是一块"地盘", 一个代码段所在的区域
- 它是静态的(相对于上下文对象), 在编写代码时就确定了

2. 分类

- 全局作用域
- 函数作用域
- 没有块作用域(ES6 有了)

3. 作用

- 隔离变量，不同作用域下同名变量不会有冲突

## 异步与单线程，执行顺序

. 如何证明 js 执行是单线程的?

- setTimeout()的回调函数是在主线程执行的
- 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

2. 为什么 js 要用单线程模式, 而不用多线程模式?

- JavaScript 的单线程，与它的用途有关。
- 作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。
- 这决定了它只能是单线程，否则会带来很复杂的同步问题

3. 代码的分类:

- 初始化代码
- 回调代码

4. js 引擎执行代码的基本流程

- 先执行初始化代码: 包含一些特别的代码
- 设置定时器
- 绑定监听
- 发送 ajax 请求
- 后面在某个时刻才会执行回调代码

## 深浅拷贝

## Webpack 的 loader 与 plugin 的理解

- Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。
  因为 Webpack 只认识 JavaScript 和 json，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。
- Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
- Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。
- Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

## Webpack 的热更新原理

> Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。

HMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新

- 通过 webpack-dev-server 创建两个服务器：提供静态资源的服务（express）和 Socket 服务
- express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）
- socket server 是一个 websocket 的长连接，双方可以通信
- 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）
- 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）
- 浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新

## 编写 loader 的思路

- Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用
- Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据
- 尽可能的异步化 Loader，如果计算量很小，同步也可以
- Loader 是无状态的，我们不应该在 Loader 中保留状态
- 使用 loader-utils 和 schema-utils 为我们提供的实用工具
- 加载本地 Loader 方法
  - Npm link
  - ResolveLoader

## 编写 Plugin 的思路

> webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。

- compiler 暴露了和 Webpack 整个生命周期相关的钩子
- compilation 暴露了与模块和依赖有关的粒度更小的事件钩子
- 插件需要在其原型上绑定 apply 方法，才能访问 compiler 实例
- 传给每个插件的 compiler 和 compilation 对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件
- 找出合适的事件点去完成想要的功能
  - emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)
  - watch-run 当依赖的文件发生变化时会触发
- 异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住
